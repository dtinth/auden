path / {
  write() { isAdmin() }
  read() { isAdmin() }
}

// User can check if they are admin or not...
path /admins/{uid} {
  read() { isCurrentUser(uid) }
}

// User can write to their own profile
path /profiles/{uid} is Profile {
  read() { true }
  write() { isCurrentUser(uid) }
}
type Profile {
  displayName: String
}

// Anyone can see which scene is active
path /currentScene is String {
  read() { true }
}

// Anyone can see which screen is active
path /currentScreen is String {
  read() { true }
}

path /screenList {
  path /{orderKey} is String {}
}

type Event {
  owner: CurrentUser
  timestamp: CurrentTimestamp
  payload: Object | Null
}
path /screenData {
  path /{screenId} {
    path /info {
      // Public information and metadata about the screen
      path /scene is String {}
      read() { true }
    }

    path /public {
      path /read-only {
        // Anyone can read but only writable by admin
        read() { true }
      }
      path /append-only {
        path /{channelName} {
          read() { true }
          path /{eventId} is Event {
            index() { [ "timestamp" ] }
            write() { createOnly(this) }
          }
        }
      }
    }

    path /users/{uid} {
      // Data private to user
      path /read-only {
        // Read/write by user
        read() { isCurrentUser(uid) }
        write() { isCurrentUser(uid) }
      }
      path /writable {
        // Read only by user
        read() { isCurrentUser(uid) }
      }
    }
  }
}

path /scenes {
  path /quiz {
    // Everyone can read the current state of quiz
    path /state {
      read() { true }
    }
    // Audience can submit answer to current question.
    path /answers/{qid}/{uid} is Answer {
      read() { isCurrentUser(uid) }
      write() { isCurrentUser(uid) && this.parent().parent().parent().state.currentQuestion.questionId == qid }
    }
  }
  path /vote {
    path /settings {
      read() { true }
    }
    path /options {
      read() { true }
    }
    path /votes/{uid} {
      read() { isCurrentUser(uid) }
      write() { isCurrentUser(uid) }
    }
  }
}
type Answer {
  answerId: String
  timestamp: CurrentTimestamp
}
type CurrentTimestamp extends Number {
  validate() { this == now }
}
type CurrentUser extends String {
  validate() { this == auth.uid }
}
isAdmin() {
  root.admins[auth.uid] == true
}
isCurrentUser(uid) {
  auth != null && auth.uid == uid
}
createOnly(value) {
  prior(value) == null && value != null
}